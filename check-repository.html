<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="ioBroker Bot - Repository Checker">
    <title>Repository Checker - ioBroker Bot</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 12px;
            padding: 45px 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 700px;
            width: 100%;
        }

        h1 {
            color: #333;
            font-size: 2em;
            margin-bottom: 8px;
            font-weight: 700;
            text-align: center;
        }

        .icon {
            font-size: 3em;
            margin-bottom: 15px;
            text-align: center;
        }

        .description {
            color: #666;
            font-size: 1em;
            line-height: 1.5;
            margin-bottom: 20px;
            text-align: center;
        }

        .form-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            color: #333;
            font-weight: 600;
            margin-bottom: 8px;
            font-size: 1em;
        }

        input[type="text"] {
            width: 100%;
            padding: 12px 16px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 1em;
            transition: border-color 0.2s;
            font-family: inherit;
        }

        input[type="text"]:focus {
            outline: none;
            border-color: #667eea;
        }

        input[type="text"].invalid {
            border-color: #e74c3c;
        }

        input[type="text"].valid {
            border-color: #27ae60;
        }

        .help-text {
            color: #999;
            font-size: 0.9em;
            margin-top: 5px;
        }

        .error-text {
            color: #e74c3c;
            font-size: 0.9em;
            margin-top: 5px;
            display: none;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        .checkbox-label {
            display: inline;
            cursor: pointer;
            margin-bottom: 0;
        }

        button {
            width: 100%;
            padding: 14px 24px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 1.1em;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s, opacity 0.2s;
            margin-top: 10px;
        }

        button:hover:not(:disabled) {
            background: #5568d3;
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
            opacity: 0.6;
        }

        .back-link {
            display: inline-block;
            margin-top: 20px;
            color: #667eea;
            text-decoration: none;
            font-weight: 600;
            text-align: center;
            width: 100%;
        }

        .back-link:hover {
            text-decoration: underline;
        }

        .status-message {
            padding: 12px 16px;
            border-radius: 6px;
            margin-bottom: 20px;
            display: none;
            text-align: center;
        }

        .status-message.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status-message.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .status-message.info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        .progress-container {
            margin-top: 20px;
            display: none;
        }

        .progress-step {
            padding: 12px 16px;
            border-radius: 6px;
            margin-bottom: 10px;
            border: 1px solid #ddd;
            background: #f8f9fa;
            text-align: left;
        }

        .progress-step.pending {
            opacity: 0.6;
        }

        .progress-step.running {
            background: #fff3cd;
            border-color: #ffc107;
        }

        .progress-step.success {
            background: #d4edda;
            border-color: #28a745;
        }

        .progress-step.error {
            background: #f8d7da;
            border-color: #dc3545;
        }

        .progress-step-title {
            font-weight: 600;
            margin-bottom: 5px;
        }

        .progress-step-status {
            font-size: 0.9em;
            color: #666;
        }

        .progress-step-link {
            color: #667eea;
            text-decoration: none;
            font-weight: 600;
        }

        .progress-step-link:hover {
            text-decoration: underline;
        }

        .issue-link {
            display: inline-block;
            margin-top: 10px;
            padding: 10px 16px;
            background: #667eea;
            color: white;
            text-decoration: none;
            border-radius: 6px;
            font-weight: 600;
        }

        .issue-link:hover {
            background: #5568d3;
        }

        @media (max-width: 600px) {
            h1 {
                font-size: 2em;
            }

            .container {
                padding: 30px 20px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="icon">üîç</div>
        <h1>Repository Checker</h1>
        <p class="description">
            This tool will trigger a repository check on the selected adapter repository. 
            The check will analyze your repository for compliance with ioBroker best practices and coding standards.
        </p>

        <div id="statusMessage" class="status-message"></div>

        <div id="progressContainer" class="progress-container">
            <div id="step1" class="progress-step pending">
                <div class="progress-step-title">1. Validating repository</div>
                <div class="progress-step-status">Pending...</div>
            </div>
            <div id="step2" class="progress-step pending">
                <div class="progress-step-title">2. Triggering workflow</div>
                <div class="progress-step-status">Pending...</div>
            </div>
            <div id="step3" class="progress-step pending">
                <div class="progress-step-title">3. Waiting for intermediate workflow</div>
                <div class="progress-step-status">Pending...</div>
            </div>
            <div id="step4" class="progress-step pending">
                <div class="progress-step-title">4. Waiting for repository check</div>
                <div class="progress-step-status">Pending...</div>
            </div>
        </div>

        <form id="checkForm">
            <div class="form-group">
                <label for="repository">Repository URL or Owner/Repository Name</label>
                <input 
                    type="text" 
                    id="repository" 
                    name="repository" 
                    placeholder="e.g., iobroker-community-adapters/ioBroker.template or https://github.com/..."
                    required
                >
                <div class="help-text">Enter either "owner/repository" format or a full GitHub URL</div>
                <div class="error-text" id="repositoryError">Please enter a valid repository identifier</div>
            </div>

            <div class="form-group">
                <div class="checkbox-group">
                    <input 
                        type="checkbox" 
                        id="recreate" 
                        name="recreate"
                    >
                    <label for="recreate" class="checkbox-label">
                        Recreate check (force creation of a new issue even if one exists)
                    </label>
                </div>
            </div>

            <button type="submit" id="executeBtn" disabled>Execute</button>
        </form>

        <a href="index.html" class="back-link">‚Üê Back to Tools</a>
    </div>

    <script src="config.js"></script>
    <script>
        const repositoryInput = document.getElementById('repository');
        const recreateCheckbox = document.getElementById('recreate');
        const executeBtn = document.getElementById('executeBtn');
        const checkForm = document.getElementById('checkForm');
        const statusMessage = document.getElementById('statusMessage');
        const repositoryError = document.getElementById('repositoryError');
        const progressContainer = document.getElementById('progressContainer');

        // Regular expressions for validation
        const ownerRepoPattern = /^[a-zA-Z0-9_-]+\/[a-zA-Z0-9_.-]+$/;
        const githubUrlPattern = /^https?:\/\/(www\.)?github\.com\/([a-zA-Z0-9_-]+)\/([a-zA-Z0-9_.-]+)(\.git)?$/;

        // Utility function to format GitHub token with proper prefix
        function formatGitHubToken(token) {
            if (!token) return null;
            // Only add prefix if the token doesn't already have a recognized GitHub token prefix
            const hasPrefix = token.startsWith('github_pat_') || 
                            token.startsWith('ghp_') || 
                            token.startsWith('gho_') || 
                            token.startsWith('ghu_') || 
                            token.startsWith('ghs_') || 
                            token.startsWith('ghr_');
            return hasPrefix ? token : `github_pat_${token}`;
        }

        // Utility function to build GitHub API headers
        function buildGitHubHeaders(token) {
            const headers = {
                'Accept': 'application/vnd.github.v3+json'
            };
            
            if (token) {
                headers['Authorization'] = `Bearer ${token}`;
            }
            
            return headers;
        }

        function validateRepository(value) {
            if (!value || value.trim() === '') {
                return false;
            }

            value = value.trim();

            // Check if it matches owner/repo format
            if (ownerRepoPattern.test(value)) {
                return true;
            }

            // Check if it matches GitHub URL format
            if (githubUrlPattern.test(value)) {
                return true;
            }

            return false;
        }

        function extractOwnerRepo(value) {
            value = value.trim();

            // If it's in owner/repo format, return as-is
            if (ownerRepoPattern.test(value)) {
                return value;
            }

            // If it's a GitHub URL, extract owner/repo
            const match = value.match(githubUrlPattern);
            if (match) {
                return `${match[2]}/${match[3]}`;
            }

            return null;
        }

        function updateButtonState() {
            const isValid = validateRepository(repositoryInput.value);
            executeBtn.disabled = !isValid;

            if (repositoryInput.value.trim() !== '') {
                if (isValid) {
                    repositoryInput.classList.remove('invalid');
                    repositoryInput.classList.add('valid');
                    repositoryError.style.display = 'none';
                } else {
                    repositoryInput.classList.remove('valid');
                    repositoryInput.classList.add('invalid');
                    repositoryError.style.display = 'block';
                }
            } else {
                repositoryInput.classList.remove('valid', 'invalid');
                repositoryError.style.display = 'none';
            }
        }

        function showStatus(message, type) {
            statusMessage.textContent = message;
            statusMessage.className = `status-message ${type}`;
            statusMessage.style.display = 'block';
        }

        function hideStatus() {
            statusMessage.style.display = 'none';
        }

        function updateProgressStep(stepId, status, statusText) {
            const step = document.getElementById(stepId);
            step.className = `progress-step ${status}`;
            step.querySelector('.progress-step-status').innerHTML = statusText;
        }

        function showProgress() {
            progressContainer.style.display = 'block';
        }

        function hideProgress() {
            progressContainer.style.display = 'none';
            // Reset all steps
            ['step1', 'step2', 'step3', 'step4'].forEach(id => {
                updateProgressStep(id, 'pending', 'Pending...');
            });
        }

        async function verifyRepositoryExists(ownerRepo, token) {
            try {
                const [owner, repo] = ownerRepo.split('/');
                const response = await fetch(
                    `https://api.github.com/repos/${owner}/${repo}`,
                    { 
                        headers: buildGitHubHeaders(token),
                        cache: 'no-store'
                    }
                );

                if (response.status === 200) {
                    return { exists: true, data: await response.json() };
                } else if (response.status === 404) {
                    return { exists: false, error: 'Repository not found' };
                } else {
                    return { exists: false, error: `HTTP ${response.status}: ${response.statusText}` };
                }
            } catch (error) {
                return { exists: false, error: error.message };
            }
        }

        async function waitForWorkflowRun(owner, repo, workflowId, token, startTime, timeout = 120000) {
            const endTime = Date.now() + timeout;
            
            while (Date.now() < endTime) {
                try {
                    const response = await fetch(
                        `https://api.github.com/repos/${owner}/${repo}/actions/workflows/${workflowId}/runs?per_page=5&_=${Date.now()}`,
                        { 
                            headers: buildGitHubHeaders(token),
                            cache: 'no-store'
                        }
                    );

                    if (response.ok) {
                        const data = await response.json();
                        // Find the most recent run that started after our trigger
                        // Convert both timestamps to milliseconds since epoch for comparison
                        const run = data.workflow_runs.find(r => new Date(r.created_at).getTime() >= startTime);
                        
                        if (run) {
                            return { success: true, run };
                        }
                    }
                } catch (error) {
                    console.error('Error fetching workflow run:', error);
                }

                // Wait 2 seconds before next check
                await new Promise(resolve => setTimeout(resolve, 2000));
            }

            return { success: false, error: 'Timeout waiting for workflow to start' };
        }

        async function monitorWorkflowRun(owner, repo, runId, token, timeout = 300000) {
            const endTime = Date.now() + timeout;
            
            while (Date.now() < endTime) {
                try {
                    const response = await fetch(
                        `https://api.github.com/repos/${owner}/${repo}/actions/runs/${runId}?_=${Date.now()}`,
                        { 
                            headers: buildGitHubHeaders(token),
                            cache: 'no-store'
                        }
                    );

                    if (response.ok) {
                        const run = await response.json();
                        
                        if (run.status === 'completed') {
                            return {
                                success: true,
                                conclusion: run.conclusion,
                                run
                            };
                        }
                    }
                } catch (error) {
                    console.error('Error monitoring workflow run:', error);
                }

                // Wait 3 seconds before next check
                await new Promise(resolve => setTimeout(resolve, 3000));
            }

            return { success: false, error: 'Timeout waiting for workflow to complete' };
        }

        async function findCheckIssue(targetRepo, token) {
            try {
                const [owner, repo] = targetRepo.split('/');
                // Search for issues with the specific title
                const searchQuery = encodeURIComponent(`repo:${owner}/${repo} is:issue "Please consider fixing issues detected by repository checker" in:title`);
                const response = await fetch(
                    `https://api.github.com/search/issues?q=${searchQuery}&sort=created&order=desc&per_page=1&_=${Date.now()}`,
                    { 
                        headers: buildGitHubHeaders(token),
                        cache: 'no-store'
                    }
                );

                if (response.ok) {
                    const data = await response.json();
                    if (data.items && data.items.length > 0) {
                        return { success: true, issue: data.items[0] };
                    }
                }
            } catch (error) {
                console.error('Error finding check issue:', error);
            }

            return { success: false };
        }

        repositoryInput.addEventListener('input', updateButtonState);
        repositoryInput.addEventListener('blur', updateButtonState);

        checkForm.addEventListener('submit', async (e) => {
            e.preventDefault();

            const repoValue = repositoryInput.value.trim();
            if (!validateRepository(repoValue)) {
                showStatus('Please enter a valid repository identifier', 'error');
                return;
            }

            const ownerRepo = extractOwnerRepo(repoValue);
            const recreate = recreateCheckbox.checked;

            // Disable form during submission
            executeBtn.disabled = true;
            repositoryInput.disabled = true;
            recreateCheckbox.disabled = true;

            hideStatus();
            showProgress();

            try {
                // Check if GitHub token is configured
                const config = window.REPO_CHECKER_CONFIG;
                if (!config || !config.GITHUB_TOKEN || config.GITHUB_TOKEN === '') {
                    showStatus(
                        'Configuration incomplete: GitHub token not set. Please contact the repository administrator to configure the GITHUB_TOKEN in config.js',
                        'error'
                    );
                    hideProgress();
                    repositoryInput.disabled = false;
                    recreateCheckbox.disabled = false;
                    updateButtonState();
                    return;
                }

                const token = formatGitHubToken(config.GITHUB_TOKEN);

                // Step 1: Verify repository exists
                updateProgressStep('step1', 'running', 'Checking if repository exists...');
                const repoCheck = await verifyRepositoryExists(ownerRepo, token);
                
                if (!repoCheck.exists) {
                    updateProgressStep('step1', 'error', `Failed: ${repoCheck.error}`);
                    showStatus(`Repository verification failed: ${repoCheck.error}`, 'error');
                    repositoryInput.disabled = false;
                    recreateCheckbox.disabled = false;
                    updateButtonState();
                    return;
                }

                updateProgressStep('step1', 'success', `Repository verified: ${repoCheck.data.full_name}`);

                // Step 2: Trigger the workflow
                updateProgressStep('step2', 'running', 'Triggering workflow...');
                // Use Date.now() to get current time in milliseconds since epoch (UTC)
                // This is timezone-independent and can be directly compared with GitHub API timestamps
                const startTime = Date.now();
                
                const response = await fetch(
                    `https://api.github.com/repos/${config.OWNER}/${config.REPO}/actions/workflows/${config.WORKFLOW_ID}/dispatches`,
                    {
                        method: 'POST',
                        headers: {
                            ...buildGitHubHeaders(token),
                            'Content-Type': 'application/json'
                        },
                        cache: 'no-store',
                        body: JSON.stringify({
                            ref: 'main',
                            inputs: {
                                repository: ownerRepo,
                                recreate: recreate.toString()
                            }
                        })
                    }
                );

                if (response.status !== 204 && response.status !== 200) {
                    updateProgressStep('step2', 'error', `Failed: HTTP ${response.status}`);
                    
                    if (response.status === 401) {
                        showStatus('Authentication failed: Invalid or expired GitHub token.', 'error');
                    } else if (response.status === 404) {
                        showStatus('Workflow not found.', 'error');
                    } else {
                        const errorData = await response.json().catch(() => ({}));
                        showStatus(`Failed to trigger workflow: ${errorData.message || response.statusText}`, 'error');
                    }
                    
                    repositoryInput.disabled = false;
                    recreateCheckbox.disabled = false;
                    updateButtonState();
                    return;
                }

                updateProgressStep('step2', 'success', 'Workflow triggered successfully');

                // Step 3: Wait for and monitor intermediate workflow
                updateProgressStep('step3', 'running', 'Waiting for intermediate workflow to start...');
                
                const waitResult = await waitForWorkflowRun(
                    config.OWNER,
                    config.REPO,
                    config.WORKFLOW_ID,
                    token,
                    startTime
                );

                if (!waitResult.success) {
                    updateProgressStep('step3', 'error', waitResult.error);
                    showStatus('Failed to find workflow run. Check the Actions tab manually.', 'error');
                    repositoryInput.disabled = false;
                    recreateCheckbox.disabled = false;
                    updateButtonState();
                    return;
                }

                const intermediateRun = waitResult.run;
                updateProgressStep('step3', 'running', `Monitoring check workflow run <a href="${intermediateRun.html_url}" target="_blank" rel="noopener noreferrer" class="progress-step-link">${config.OWNER}/${config.REPO}#${intermediateRun.id}</a>...`);

                const monitorResult = await monitorWorkflowRun(
                    config.OWNER,
                    config.REPO,
                    intermediateRun.id,
                    token
                );

                if (!monitorResult.success) {
                    updateProgressStep('step3', 'error', monitorResult.error);
                    showStatus('Workflow monitoring timed out. Check the Actions tab manually.', 'error');
                    repositoryInput.disabled = false;
                    recreateCheckbox.disabled = false;
                    updateButtonState();
                    return;
                }

                if (monitorResult.conclusion === 'success') {
                    updateProgressStep('step3', 'success', 'Intermediate workflow completed successfully');
                } else {
                    updateProgressStep('step3', 'error', `Workflow failed with conclusion: ${monitorResult.conclusion}`);
                    showStatus(`Intermediate workflow failed: ${monitorResult.conclusion}`, 'error');
                    repositoryInput.disabled = false;
                    recreateCheckbox.disabled = false;
                    updateButtonState();
                    return;
                }

                // Step 4: Monitor target workflow in check-tasks
                updateProgressStep('step4', 'running', 'Waiting for repository check workflow...');
                
                const targetWaitResult = await waitForWorkflowRun(
                    config.CHECK_TASKS_OWNER,
                    config.CHECK_TASKS_REPO,
                    config.CHECK_TASKS_WORKFLOW_ID,
                    token,
                    startTime,
                    180000 // 3 minutes timeout
                );

                if (!targetWaitResult.success) {
                    updateProgressStep('step4', 'running', 'Workflow may still be running. Checking for issue...');
                    // Continue to check for issue even if we can't find the workflow
                } else {
                    updateProgressStep('step4', 'running', `Monitoring check workflow run <a href="${targetWaitResult.run.html_url}" target="_blank" rel="noopener noreferrer" class="progress-step-link">${config.CHECK_TASKS_OWNER}/${config.CHECK_TASKS_REPO}#${targetWaitResult.run.id}</a>...`);

                    const targetMonitorResult = await monitorWorkflowRun(
                        config.CHECK_TASKS_OWNER,
                        config.CHECK_TASKS_REPO,
                        targetWaitResult.run.id,
                        token,
                        600000 // 10 minutes timeout for the actual check
                    );

                    if (targetMonitorResult.success) {
                        if (targetMonitorResult.conclusion === 'success') {
                            updateProgressStep('step4', 'success', 'Repository check completed successfully');
                        } else {
                            updateProgressStep('step4', 'error', `Check failed: ${targetMonitorResult.conclusion}`);
                        }
                    } else {
                        updateProgressStep('step4', 'running', 'Check is taking longer than expected. Looking for issue...');
                    }
                }

                // Try to find the issue
                const issueResult = await findCheckIssue(ownerRepo, token);
                
                if (issueResult.success) {
                    const issueLink = document.createElement('a');
                    issueLink.href = issueResult.issue.html_url;
                    issueLink.className = 'issue-link';
                    issueLink.target = '_blank';
                    issueLink.rel = 'noopener noreferrer';
                    issueLink.textContent = `View Check Issue #${issueResult.issue.number}`;
                    
                    const step4 = document.getElementById('step4');
                    step4.appendChild(issueLink);
                    
                    showStatus(
                        `Repository check completed! View the results in issue #${issueResult.issue.number}`,
                        'success'
                    );
                } else {
                    showStatus(
                        'Repository check has been triggered. Check the target repository for the issue.',
                        'success'
                    );
                }

                // Clear form after success
                setTimeout(() => {
                    repositoryInput.value = '';
                    recreateCheckbox.checked = false;
                    hideStatus();
                    hideProgress();
                    repositoryInput.disabled = false;
                    recreateCheckbox.disabled = false;
                    updateButtonState();
                }, 10000);

            } catch (error) {
                showStatus(`Error: ${error.message}`, 'error');
                hideProgress();
                repositoryInput.disabled = false;
                recreateCheckbox.disabled = false;
                updateButtonState();
            }
        });
    </script>
</body>
</html>

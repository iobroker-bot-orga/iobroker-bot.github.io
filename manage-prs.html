<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="ioBroker Bot - Manage PRs">
    <title>Manage PRs - ioBroker Bot</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 12px;
            padding: 45px 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 700px;
            width: 100%;
        }

        h1 {
            color: #333;
            font-size: 2em;
            margin-bottom: 8px;
            font-weight: 700;
            text-align: center;
        }

        .icon {
            font-size: 3em;
            margin-bottom: 15px;
            text-align: center;
        }

        .description {
            color: #666;
            font-size: 1em;
            line-height: 1.5;
            margin-bottom: 20px;
            text-align: center;
        }

        .form-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            color: #333;
            font-weight: 600;
            margin-bottom: 8px;
            font-size: 1em;
        }

        input[type="text"],
        select {
            width: 100%;
            padding: 12px 16px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 1em;
            transition: border-color 0.2s;
            font-family: inherit;
        }

        input[type="text"]:focus,
        select:focus {
            outline: none;
            border-color: #667eea;
        }

        input[type="text"].invalid {
            border-color: #e74c3c;
        }

        input[type="text"].valid {
            border-color: #27ae60;
        }

        select {
            cursor: pointer;
        }

        .help-text {
            color: #999;
            font-size: 0.9em;
            margin-top: 5px;
        }

        .error-text {
            color: #e74c3c;
            font-size: 0.9em;
            margin-top: 5px;
            display: none;
        }

        button {
            width: 100%;
            padding: 14px 24px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 1.1em;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s, opacity 0.2s;
            margin-top: 10px;
        }

        button:hover:not(:disabled) {
            background: #5568d3;
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
            opacity: 0.6;
        }

        .back-link {
            display: inline-block;
            margin-top: 20px;
            color: #667eea;
            text-decoration: none;
            font-weight: 600;
            text-align: center;
            width: 100%;
        }

        .back-link:hover {
            text-decoration: underline;
        }

        .status-message {
            padding: 12px 16px;
            border-radius: 6px;
            margin-bottom: 20px;
            display: none;
            text-align: center;
        }

        .status-message.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status-message.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .status-message.info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        .progress-container {
            margin-top: 20px;
            display: none;
        }

        .progress-step {
            padding: 12px 16px;
            border-radius: 6px;
            margin-bottom: 10px;
            border: 1px solid #ddd;
            background: #f8f9fa;
            text-align: left;
        }

        .progress-step.pending {
            opacity: 0.6;
        }

        .progress-step.running {
            background: #fff3cd;
            border-color: #ffc107;
        }

        .progress-step.success {
            background: #d4edda;
            border-color: #28a745;
        }

        .progress-step.error {
            background: #f8d7da;
            border-color: #dc3545;
        }

        .progress-step-title {
            font-weight: 600;
            margin-bottom: 5px;
        }

        .progress-step-status {
            font-size: 0.9em;
            color: #666;
        }

        .progress-step-link {
            color: #667eea;
            text-decoration: none;
            font-weight: 600;
        }

        .progress-step-link:hover {
            text-decoration: underline;
        }

        .pr-link {
            display: inline-block;
            margin-top: 10px;
            padding: 10px 16px;
            background: #667eea;
            color: white;
            text-decoration: none;
            border-radius: 6px;
            font-weight: 600;
        }

        .pr-link:hover {
            background: #5568d3;
        }

        @media (max-width: 600px) {
            h1 {
                font-size: 2em;
            }

            .container {
                padding: 30px 20px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="icon">üîß</div>
        <h1>Manage PRs</h1>
        <p class="description">
            This tool will create a new Pull Request at the selected repository using a template. 
            Select a repository, choose a template, and configure the PR behavior.
        </p>

        <div id="statusMessage" class="status-message"></div>

        <div id="progressContainer" class="progress-container">
            <div id="step1" class="progress-step pending">
                <div class="progress-step-title">1. Validating repository</div>
                <div class="progress-step-status">Pending...</div>
            </div>
            <div id="step2" class="progress-step pending">
                <div class="progress-step-title">2. Loading templates</div>
                <div class="progress-step-status">Pending...</div>
            </div>
            <div id="step3" class="progress-step pending">
                <div class="progress-step-title">3. Triggering workflow</div>
                <div class="progress-step-status">Pending...</div>
            </div>
            <div id="step4" class="progress-step pending">
                <div class="progress-step-title">4. Waiting for intermediate workflow</div>
                <div class="progress-step-status">Pending...</div>
            </div>
            <div id="step5" class="progress-step pending">
                <div class="progress-step-title">5. Waiting for PR creation</div>
                <div class="progress-step-status">Pending...</div>
            </div>
        </div>

        <form id="managePrForm">
            <div class="form-group">
                <label for="repository">Repository URL or Owner/Repository Name</label>
                <input 
                    type="text" 
                    id="repository" 
                    name="repository" 
                    placeholder="e.g., iobroker-community-adapters/ioBroker.template or https://github.com/..."
                    required
                >
                <div class="help-text">Enter either "owner/repository" format or a full GitHub URL</div>
                <div class="error-text" id="repositoryError">Please enter a valid repository identifier</div>
            </div>

            <div class="form-group">
                <label for="template">Template</label>
                <select id="template" name="template" required disabled>
                    <option value="">Loading templates...</option>
                </select>
                <div class="help-text">Select a template to apply to the repository</div>
                <div class="error-text" id="templateError">Failed to load templates</div>
            </div>

            <div class="form-group">
                <label for="parameter_data">Parameter Data (Optional)</label>
                <input 
                    type="text" 
                    id="parameter_data" 
                    name="parameter_data" 
                    placeholder="Optional parameter data for the template"
                >
                <div class="help-text">Optional parameter data to pass to the template</div>
            </div>

            <div class="form-group">
                <label for="pr_mode">PR Mode</label>
                <select id="pr_mode" name="pr_mode" required>
                    <option value="recreate" selected>Recreate (default)</option>
                    <option value="force creation">Force creation</option>
                    <option value="skip if existing">Skip if existing</option>
                    <option value="skip if closed">Skip if closed</option>
                    <option value="skip if merged">Skip if merged</option>
                    <option value="REVOKE">REVOKE</option>
                </select>
                <div class="help-text">How to handle existing PRs</div>
            </div>

            <button type="submit" id="executeBtn" disabled>Execute</button>
        </form>

        <a href="index.html" class="back-link">‚Üê Back to Tools</a>
    </div>

    <script src="config.js"></script>
    <script>
        const repositoryInput = document.getElementById('repository');
        const templateSelect = document.getElementById('template');
        const parameterDataInput = document.getElementById('parameter_data');
        const prModeSelect = document.getElementById('pr_mode');
        const executeBtn = document.getElementById('executeBtn');
        const managePrForm = document.getElementById('managePrForm');
        const statusMessage = document.getElementById('statusMessage');
        const repositoryError = document.getElementById('repositoryError');
        const templateError = document.getElementById('templateError');
        const progressContainer = document.getElementById('progressContainer');

        // Regular expressions for validation
        const ownerRepoPattern = /^[a-zA-Z0-9_-]+\/[a-zA-Z0-9_.-]+$/;
        const githubUrlPattern = /^https?:\/\/(www\.)?github\.com\/([a-zA-Z0-9_-]+)\/([a-zA-Z0-9_.-]+)(\.git)?$/;

        // Utility function to format GitHub token with proper prefix
        function formatGitHubToken(token) {
            if (!token) return null;
            // Only add prefix if the token doesn't already have a recognized GitHub token prefix
            const hasPrefix = token.startsWith('github_pat_') || 
                            token.startsWith('ghp_') || 
                            token.startsWith('gho_') || 
                            token.startsWith('ghu_') || 
                            token.startsWith('ghs_') || 
                            token.startsWith('ghr_');
            return hasPrefix ? token : `github_pat_${token}`;
        }

        // Utility function to build GitHub API headers
        function buildGitHubHeaders(token) {
            const headers = {
                'Accept': 'application/vnd.github.v3+json'
            };
            
            if (token) {
                headers['Authorization'] = `Bearer ${token}`;
            }
            
            return headers;
        }

        // Sanitize text content to prevent XSS
        function escapeHtml(text) {
            if (text === null || text === undefined) {
                return '';
            }
            const div = document.createElement('div');
            div.textContent = String(text);
            return div.innerHTML;
        }

        // Safely create a link element
        function createSafeLink(url, text, className) {
            // Validate URL is from GitHub (must start with the exact GitHub domain)
            if (!url || typeof url !== 'string') {
                return escapeHtml(text);
            }
            
            try {
                const parsedUrl = new URL(url);
                // Only allow github.com and api.github.com as the exact hostname
                if (parsedUrl.hostname !== 'github.com' && parsedUrl.hostname !== 'api.github.com') {
                    return escapeHtml(text);
                }
                // Ensure https protocol
                if (parsedUrl.protocol !== 'https:') {
                    return escapeHtml(text);
                }
            } catch (e) {
                return escapeHtml(text);
            }
            
            const link = document.createElement('a');
            link.href = url;
            link.textContent = String(text);
            link.target = '_blank';
            link.rel = 'noopener noreferrer';
            if (className) {
                link.className = className;
            }
            return link.outerHTML;
        }

        function validateRepository(value) {
            if (!value || value.trim() === '') {
                return false;
            }

            value = value.trim();

            // Check if it matches owner/repo format
            if (ownerRepoPattern.test(value)) {
                return true;
            }

            // Check if it matches GitHub URL format
            if (githubUrlPattern.test(value)) {
                return true;
            }

            return false;
        }

        function extractOwnerRepo(value) {
            value = value.trim();

            // If it's in owner/repo format, return as-is
            if (ownerRepoPattern.test(value)) {
                return value;
            }

            // If it's a GitHub URL, extract owner/repo
            const match = value.match(githubUrlPattern);
            if (match) {
                return `${match[2]}/${match[3]}`;
            }

            return null;
        }

        function updateButtonState() {
            const isRepoValid = validateRepository(repositoryInput.value);
            const isTemplateValid = templateSelect.value !== '' && !templateSelect.disabled;
            executeBtn.disabled = !isRepoValid || !isTemplateValid;

            if (repositoryInput.value.trim() !== '') {
                if (isRepoValid) {
                    repositoryInput.classList.remove('invalid');
                    repositoryInput.classList.add('valid');
                    repositoryError.style.display = 'none';
                } else {
                    repositoryInput.classList.remove('valid');
                    repositoryInput.classList.add('invalid');
                    repositoryError.style.display = 'block';
                }
            } else {
                repositoryInput.classList.remove('valid', 'invalid');
                repositoryError.style.display = 'none';
            }
        }

        function showStatus(message, type) {
            statusMessage.textContent = message;
            statusMessage.className = `status-message ${type}`;
            statusMessage.style.display = 'block';
        }

        function hideStatus() {
            statusMessage.style.display = 'none';
        }

        function updateProgressStep(stepId, status, statusText) {
            const step = document.getElementById(stepId);
            step.className = `progress-step ${status}`;
            const statusElement = step.querySelector('.progress-step-status');
            // Check if statusText contains safe HTML from createSafeLink
            // Only allow innerHTML if it's a string and contains an anchor tag with a validated GitHub URL
            if (typeof statusText === 'string' && /<a\s/i.test(statusText)) {
                // Additional validation: ensure it's from our createSafeLink function
                // by checking for both the anchor tag and the GitHub-specific attributes
                if (statusText.includes('target="_blank"') && statusText.includes('rel="noopener noreferrer"')) {
                    statusElement.innerHTML = statusText;
                } else {
                    statusElement.textContent = statusText;
                }
            } else {
                statusElement.textContent = statusText;
            }
        }

        function showProgress() {
            progressContainer.style.display = 'block';
        }

        function hideProgress() {
            progressContainer.style.display = 'none';
            // Reset all steps
            ['step1', 'step2', 'step3', 'step4', 'step5'].forEach(id => {
                updateProgressStep(id, 'pending', 'Pending...');
            });
        }

        async function loadTemplates() {
            try {
                const config = window.MANAGE_PRS_CONFIG;
                if (!config) {
                    throw new Error('Configuration not loaded');
                }

                const token = config.GITHUB_TOKEN ? formatGitHubToken(config.GITHUB_TOKEN) : null;
                
                // Fetch the templates directory from GitHub API
                const response = await fetch(
                    `https://api.github.com/repos/${config.MANAGE_PRS_TEMPLATES_REPO}/contents/${config.MANAGE_PRS_TEMPLATES_PATH}?ref=${config.MANAGE_PRS_TEMPLATES_BRANCH}`,
                    { 
                        headers: buildGitHubHeaders(token),
                        cache: 'no-store'
                    }
                );

                if (!response.ok) {
                    throw new Error(`Failed to fetch templates: ${response.status}`);
                }

                const items = await response.json();
                
                // Filter directories that don't start with underscore
                const templates = items
                    .filter(item => item.type === 'dir' && !item.name.startsWith('_'))
                    .map(item => item.name)
                    .sort();

                if (templates.length === 0) {
                    throw new Error('No templates found in the templates directory. Please check the repository configuration or contact your administrator.');
                }

                // Populate the select dropdown
                templateSelect.innerHTML = '<option value="">Select a template...</option>';
                templates.forEach(template => {
                    const option = document.createElement('option');
                    option.value = template;
                    option.textContent = template;
                    templateSelect.appendChild(option);
                });

                templateSelect.disabled = false;
                templateError.style.display = 'none';
                updateButtonState();
            } catch (error) {
                console.error('Error loading templates:', error);
                templateSelect.innerHTML = '<option value="">Failed to load templates</option>';
                templateSelect.disabled = true;
                templateError.textContent = `Failed to load templates: ${error.message}`;
                templateError.style.display = 'block';
                updateButtonState();
            }
        }

        async function verifyRepositoryExists(ownerRepo, token) {
            try {
                const [owner, repo] = ownerRepo.split('/');
                const response = await fetch(
                    `https://api.github.com/repos/${owner}/${repo}`,
                    { 
                        headers: buildGitHubHeaders(token),
                        cache: 'no-store'
                    }
                );

                if (response.status === 200) {
                    return { exists: true, data: await response.json() };
                } else if (response.status === 404) {
                    return { exists: false, error: 'Repository not found' };
                } else {
                    return { exists: false, error: `HTTP ${response.status}: ${response.statusText}` };
                }
            } catch (error) {
                return { exists: false, error: error.message };
            }
        }

        async function waitForWorkflowRun(owner, repo, workflowId, token, startTime, timeout = 120000) {
            const endTime = Date.now() + timeout;
            
            while (Date.now() < endTime) {
                try {
                    const response = await fetch(
                        `https://api.github.com/repos/${owner}/${repo}/actions/workflows/${workflowId}/runs?per_page=5&_=${Date.now()}`,
                        { 
                            headers: buildGitHubHeaders(token),
                            cache: 'no-store'
                        }
                    );

                    if (response.ok) {
                        const data = await response.json();
                        const run = data.workflow_runs.find(r => new Date(r.created_at).getTime() >= startTime);
                        
                        if (run) {
                            return { success: true, run };
                        }
                    }
                } catch (error) {
                    console.error('Error fetching workflow run:', error);
                }

                await new Promise(resolve => setTimeout(resolve, 2000));
            }

            return { success: false, error: 'Timeout waiting for workflow to start' };
        }

        async function monitorWorkflowRun(owner, repo, runId, token, timeout = 300000) {
            const endTime = Date.now() + timeout;
            
            while (Date.now() < endTime) {
                try {
                    const response = await fetch(
                        `https://api.github.com/repos/${owner}/${repo}/actions/runs/${runId}?_=${Date.now()}`,
                        { 
                            headers: buildGitHubHeaders(token),
                            cache: 'no-store'
                        }
                    );

                    if (response.ok) {
                        const run = await response.json();
                        
                        if (run.status === 'completed') {
                            return {
                                success: true,
                                conclusion: run.conclusion,
                                run
                            };
                        }
                    }
                } catch (error) {
                    console.error('Error monitoring workflow run:', error);
                }

                await new Promise(resolve => setTimeout(resolve, 3000));
            }

            return { success: false, error: 'Timeout waiting for workflow to complete' };
        }

        async function findPullRequest(targetRepo, token) {
            try {
                const [owner, repo] = targetRepo.split('/');
                // Search for recent PRs from iobroker-bot
                const response = await fetch(
                    `https://api.github.com/repos/${owner}/${repo}/pulls?state=all&sort=created&direction=desc&per_page=5&_=${Date.now()}`,
                    { 
                        headers: buildGitHubHeaders(token),
                        cache: 'no-store'
                    }
                );

                if (response.ok) {
                    const pulls = await response.json();
                    // Return the most recent PR (assumes it's the one we just created)
                    if (pulls && pulls.length > 0) {
                        return { success: true, pr: pulls[0] };
                    }
                }
            } catch (error) {
                console.error('Error finding pull request:', error);
            }

            return { success: false };
        }

        repositoryInput.addEventListener('input', updateButtonState);
        repositoryInput.addEventListener('blur', updateButtonState);
        templateSelect.addEventListener('change', updateButtonState);

        // Load templates on page load
        loadTemplates();

        managePrForm.addEventListener('submit', async (e) => {
            e.preventDefault();

            const repoValue = repositoryInput.value.trim();
            if (!validateRepository(repoValue)) {
                showStatus('Please enter a valid repository identifier', 'error');
                return;
            }

            const ownerRepo = extractOwnerRepo(repoValue);
            const template = templateSelect.value;
            const parameterData = parameterDataInput.value.trim();
            const prMode = prModeSelect.value;

            // Disable form during submission
            executeBtn.disabled = true;
            repositoryInput.disabled = true;
            templateSelect.disabled = true;
            parameterDataInput.disabled = true;
            prModeSelect.disabled = true;

            hideStatus();
            showProgress();

            try {
                // Check if GitHub token is configured
                const config = window.MANAGE_PRS_CONFIG;
                if (!config || !config.GITHUB_TOKEN || config.GITHUB_TOKEN === '') {
                    showStatus(
                        'Configuration incomplete: GitHub token not set. Please contact the repository administrator to configure the GITHUB_TOKEN in config.js',
                        'error'
                    );
                    hideProgress();
                    repositoryInput.disabled = false;
                    templateSelect.disabled = false;
                    parameterDataInput.disabled = false;
                    prModeSelect.disabled = false;
                    updateButtonState();
                    return;
                }

                const token = formatGitHubToken(config.GITHUB_TOKEN);

                // Step 1: Verify repository exists
                updateProgressStep('step1', 'running', 'Checking if repository exists...');
                const repoCheck = await verifyRepositoryExists(ownerRepo, token);
                
                if (!repoCheck.exists) {
                    updateProgressStep('step1', 'error', `Failed: ${repoCheck.error}`);
                    showStatus(`Repository verification failed: ${repoCheck.error}`, 'error');
                    repositoryInput.disabled = false;
                    templateSelect.disabled = false;
                    parameterDataInput.disabled = false;
                    prModeSelect.disabled = false;
                    updateButtonState();
                    return;
                }

                updateProgressStep('step1', 'success', `Repository verified: ${escapeHtml(repoCheck.data.full_name)}`);
                updateProgressStep('step2', 'success', `Template selected: ${escapeHtml(template)}`);

                // Step 3: Trigger the workflow
                updateProgressStep('step3', 'running', 'Triggering workflow...');
                const startTime = Date.now();
                
                const response = await fetch(
                    `https://api.github.com/repos/${config.OWNER}/${config.REPO}/actions/workflows/${config.MANAGE_PRS_WORKFLOW_ID}/dispatches`,
                    {
                        method: 'POST',
                        headers: {
                            ...buildGitHubHeaders(token),
                            'Content-Type': 'application/json'
                        },
                        cache: 'no-store',
                        body: JSON.stringify({
                            ref: 'main',
                            inputs: {
                                repository: ownerRepo,
                                template: template,
                                parameter_data: parameterData,
                                pr_mode: prMode
                            }
                        })
                    }
                );

                if (response.status !== 204 && response.status !== 200) {
                    updateProgressStep('step3', 'error', `Failed: HTTP ${response.status}`);
                    
                    if (response.status === 401) {
                        showStatus('Authentication failed: Invalid or expired GitHub token.', 'error');
                    } else if (response.status === 404) {
                        showStatus('Workflow not found.', 'error');
                    } else {
                        const errorData = await response.json().catch(() => ({}));
                        showStatus(`Failed to trigger workflow: ${errorData.message || response.statusText}`, 'error');
                    }
                    
                    repositoryInput.disabled = false;
                    templateSelect.disabled = false;
                    parameterDataInput.disabled = false;
                    prModeSelect.disabled = false;
                    updateButtonState();
                    return;
                }

                updateProgressStep('step3', 'success', 'Workflow triggered successfully');

                // Step 4: Wait for and monitor intermediate workflow
                updateProgressStep('step4', 'running', 'Waiting for intermediate workflow to start...');
                
                const waitResult = await waitForWorkflowRun(
                    config.OWNER,
                    config.REPO,
                    config.MANAGE_PRS_WORKFLOW_ID,
                    token,
                    startTime
                );

                if (!waitResult.success) {
                    updateProgressStep('step4', 'error', waitResult.error);
                    showStatus('Failed to find workflow run. Check the Actions tab manually.', 'error');
                    repositoryInput.disabled = false;
                    templateSelect.disabled = false;
                    parameterDataInput.disabled = false;
                    prModeSelect.disabled = false;
                    updateButtonState();
                    return;
                }

                const intermediateRun = waitResult.run;
                const linkText = `${config.OWNER}/${config.REPO}#${intermediateRun.id}`;
                const safeLink = createSafeLink(intermediateRun.html_url, linkText, 'progress-step-link');
                updateProgressStep('step4', 'running', `Monitoring workflow run ${safeLink}...`);

                const monitorResult = await monitorWorkflowRun(
                    config.OWNER,
                    config.REPO,
                    intermediateRun.id,
                    token
                );

                if (!monitorResult.success) {
                    updateProgressStep('step4', 'error', monitorResult.error);
                    showStatus('Workflow monitoring timed out. Check the Actions tab manually.', 'error');
                    repositoryInput.disabled = false;
                    templateSelect.disabled = false;
                    parameterDataInput.disabled = false;
                    prModeSelect.disabled = false;
                    updateButtonState();
                    return;
                }

                if (monitorResult.conclusion === 'success') {
                    updateProgressStep('step4', 'success', 'Intermediate workflow completed successfully');
                } else {
                    updateProgressStep('step4', 'error', `Workflow failed with conclusion: ${monitorResult.conclusion}`);
                    showStatus(`Intermediate workflow failed: ${monitorResult.conclusion}`, 'error');
                    repositoryInput.disabled = false;
                    templateSelect.disabled = false;
                    parameterDataInput.disabled = false;
                    prModeSelect.disabled = false;
                    updateButtonState();
                    return;
                }

                // Step 5: Monitor target workflow in manage-prs
                updateProgressStep('step5', 'running', 'Waiting for PR creation workflow...');
                
                const targetWaitResult = await waitForWorkflowRun(
                    config.MANAGE_PRS_TARGET_OWNER,
                    config.MANAGE_PRS_TARGET_REPO,
                    config.MANAGE_PRS_TARGET_WORKFLOW_ID,
                    token,
                    startTime,
                    180000 // 3 minutes timeout
                );

                let workflowCompleted = false;

                if (!targetWaitResult.success) {
                    updateProgressStep('step5', 'running', 'Workflow may still be running. Checking for PR...');
                } else {
                    const linkText = `${config.MANAGE_PRS_TARGET_OWNER}/${config.MANAGE_PRS_TARGET_REPO}#${targetWaitResult.run.id}`;
                    const safeLink = createSafeLink(targetWaitResult.run.html_url, linkText, 'progress-step-link');
                    updateProgressStep('step5', 'running', `Monitoring PR creation workflow run ${safeLink}...`);

                    const targetMonitorResult = await monitorWorkflowRun(
                        config.MANAGE_PRS_TARGET_OWNER,
                        config.MANAGE_PRS_TARGET_REPO,
                        targetWaitResult.run.id,
                        token,
                        600000 // 10 minutes timeout for the actual PR creation
                    );

                    if (targetMonitorResult.success) {
                        workflowCompleted = true;
                        if (targetMonitorResult.conclusion === 'success') {
                            updateProgressStep('step5', 'success', 'PR creation completed successfully');
                        } else {
                            updateProgressStep('step5', 'error', `PR creation failed: ${targetMonitorResult.conclusion}`);
                        }
                    } else {
                        updateProgressStep('step5', 'running', 'PR creation is taking longer than expected. Looking for PR...');
                    }
                }

                // Try to find and display the PR
                if (workflowCompleted) {
                    const prResult = await findPullRequest(ownerRepo, token);
                    
                    if (prResult.success) {
                        const step5 = document.getElementById('step5');
                        const existingLinks = step5.querySelectorAll('.pr-link');
                        existingLinks.forEach(link => link.remove());
                        
                        const prLink = document.createElement('a');
                        prLink.href = prResult.pr.html_url;
                        prLink.className = 'pr-link';
                        prLink.target = '_blank';
                        prLink.rel = 'noopener noreferrer';
                        prLink.textContent = `View Pull Request #${prResult.pr.number}`;
                        
                        step5.appendChild(prLink);
                        
                        showStatus(
                            `Pull Request created successfully! View PR #${escapeHtml(prResult.pr.number)}`,
                            'success'
                        );
                    } else {
                        showStatus(
                            'PR creation completed, but could not find the PR. Check the target repository manually.',
                            'success'
                        );
                    }
                } else {
                    showStatus(
                        'PR creation has been triggered. Check the target repository for the PR.',
                        'success'
                    );
                }

                // Clear form after success
                setTimeout(() => {
                    repositoryInput.value = '';
                    templateSelect.value = '';
                    parameterDataInput.value = '';
                    prModeSelect.value = 'recreate';
                    hideStatus();
                    hideProgress();
                    repositoryInput.disabled = false;
                    templateSelect.disabled = false;
                    parameterDataInput.disabled = false;
                    prModeSelect.disabled = false;
                    updateButtonState();
                }, 20000);

            } catch (error) {
                showStatus(`Error: ${error.message}`, 'error');
                hideProgress();
                repositoryInput.disabled = false;
                templateSelect.disabled = false;
                parameterDataInput.disabled = false;
                prModeSelect.disabled = false;
                updateButtonState();
            }
        });
    </script>
</body>
</html>
